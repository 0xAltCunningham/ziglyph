
    return instance;
}

pub fn deinit(self: *Self) void {
    self.ccc_map.deinit();
    self.han_map.deinit();
    self.map.deinit();
}

/// mapping retrieves the decomposition mapping for a code point as per the UCD.
pub fn mapping(self: Self, cp: u21) Decomposed {
    return if (self.map.get(cp)) |dc| dc else .{ .same = cp };
}

/// codePointCD takes a code point and returns a sequence of code points that represent its compatibility 
/// decomposition (CD). Note that the sequence could be just a single code point, and in that case it 
/// can even be the same code point that was passed in. Given the recursive nature of this method, 
/// an std.heap.ArenaAllocator is recommeded. The caller can then easily free all memory with just
/// a call to the arena's deinit method.
pub fn codePointCD(self: Self, allocator: *mem.Allocator, cp: u21) anyerror![]u21 {
    if (self.isHangulPrecomposed(cp)) {
        // Hangul precomposed syllable full decomposition.
        const dcs = self.decomposeHangul(cp);
        const len: usize = if (dcs[2] == 0) 2 else 3;
        var result = try allocator.alloc(u21, len);
        mem.copy(u21, result, dcs[0..len]);
        return result;
    } else {
        // Other code point decomposition.
        const src = [1]Decomposed{ .{ .src = cp } };
        const dcs = try self.decomposeCD(allocator, &src);
        var result = try allocator.alloc(u21, dcs.len);
        for (dcs) |dc, index| {
            result[index] = dc.same;
        }
        return result;
    }
}

/// codePointKD takes a code point and returns a sequence of code points that represent its compatibility 
/// decomposition (KD). Note that the sequence could be just a single code point, and in that case it 
/// can even be the same code point that was passed in. Given the recursive nature of this method, 
/// an std.heap.ArenaAllocator is recommeded. The caller can then easily free all memory with just
/// a call to the arena's deinit method.
pub fn codePointKD(self: Self, allocator: *mem.Allocator, cp: u21) anyerror![]u21 {
    if (self.isHangulPrecomposed(cp)) {
        // Hangul precomposed syllable full decomposition.
        const dcs = self.decomposeHangul(cp);
        const len: usize = if (dcs[2] == 0) 2 else 3;
        var result = try allocator.alloc(u21, len);
        mem.copy(u21, result, dcs[0..len]);
        return result;
    } else {
        // Other code point decomposition.
        const src = [1]Decomposed{ .{ .src = cp } };
        const dcs = try self.decomposeKD(allocator, &src);
        var result = try allocator.alloc(u21, dcs.len);
        for (dcs) |dc, index| {
            result[index] = dc.same;
        }
        return result;
    }
}

/// decomposeCD recursively performs decomposition until full canonical decomposition (CD) is obtained. 
/// Given the recursive nature of this method, a std.heap.ArenaAllocator is the recommeded type of 
/// allocator to pass in. The caller can then easily free all memory with just a call to the arena's 
/// deinit method.
pub fn decomposeCD(self: Self, allocator: *mem.Allocator, dcs: []const Decomposed) anyerror![]const Decomposed {
    // Base case;
    if (allDone(dcs)) return dcs;

    var rdcs = std.ArrayList(Decomposed).init(allocator);
    defer rdcs.deinit();
    for (dcs) |dc| {
        switch (dc) {
            .src => |cp| {
                const next_map = self.mapping(cp);
                if (next_map == .same) {
                    try rdcs.append(next_map);
                    return rdcs.toOwnedSlice();
                } else if (next_map == .compat) {
                    try rdcs.append(.{ .same = cp });
                    return rdcs.toOwnedSlice();
                } else {
                    const m = [1]Decomposed{ self.mapping(cp) };
                    try rdcs.appendSlice(try self.decomposeCD(allocator, &m));
                }
            },
            .same => try rdcs.append(dc),
            .single => |cp| {
                const next_map = self.mapping(cp);
                if (next_map == .same or next_map == .compat) {
                    try rdcs.append(.{ .same = cp });
                } else {
                    const m = [1]Decomposed{ self.mapping(cp) };
                    try rdcs.appendSlice(try self.decomposeCD(allocator, &m));
                }
            },
            .canon => |seq| {
                for (seq) |cp| {
                    const next_map = self.mapping(cp);
                    if (next_map == .same or next_map == .compat) {
                        try rdcs.append(.{ .same = cp });
                    } else {
                        const m = [1]Decomposed{ next_map };
                        try rdcs.appendSlice(try self.decomposeCD(allocator, &m));
                    }
                }
            },
            .compat => {},
        }
    }
    return rdcs.toOwnedSlice();
}

/// decomposeKD recursively performs decomposition until full compatibility decomposition (KD) is obtained. 
/// Given the recursive nature of this method, a std.heap.ArenaAllocator is the recommeded type of 
/// allocator to pass in. The caller can then easily free all memory with just a call to the arena's 
/// deinit method.
pub fn decomposeKD(self: Self, allocator: *mem.Allocator, dcs: []const Decomposed) anyerror![]const Decomposed {
    // Base case;
    if (allDone(dcs)) return dcs;

    var rdcs = std.ArrayList(Decomposed).init(allocator);
    defer rdcs.deinit();
    for (dcs) |dc| {
        switch (dc) {
            .src => |cp| {
                const m = [1]Decomposed{ self.mapping(cp) };
                try rdcs.appendSlice(try self.decomposeKD(allocator, &m));
            },
            .same => try rdcs.append(dc),
            .single => |cp| {
                const m = [1]Decomposed{ self.mapping(cp) };
                try rdcs.appendSlice(try self.decomposeKD(allocator, &m));
            },
            .canon => |seq| {
                for (seq) |cp| {
                    const m = [1]Decomposed{ self.mapping(cp) };
                    try rdcs.appendSlice(try self.decomposeKD(allocator, &m));
                }
            },
            .compat => |seq| {
                for (seq) |cp| {
                    const m = [1]Decomposed{ self.mapping(cp) };
                    try rdcs.appendSlice(try self.decomposeKD(allocator, &m));
                }
            },
        }
    }
    return rdcs.toOwnedSlice();
}

/// toNFD will decompose the code points in str, producing a slice of u8 with the new bytes.
/// This method produces a normalization of type NFD as per Unicode. Given the recursive nature of 
/// this method, a std.heap.ArenaAllocator is the recommeded type of allocator to pass in. The 
/// caller can then easily free all memory with just a call to the arena's deinit method.
pub fn toNFD(self: *Self, allocator: *mem.Allocator, str: []const u8) anyerror![]u8 {
    // No deinit here, to be freed by caller.
    var result = std.ArrayList(u8).init(allocator);
    // This we can deinit.
    var code_points = std.ArrayList(u21).init(self.allocator);
    defer code_points.deinit();
    // Gather decomposed code points.
    var iter = (try unicode.Utf8View.init(str)).iterator();
    while (iter.nextCodepoint()) |cp| {
        try code_points.appendSlice(try self.codePointCD(allocator, cp));
    }
    // Apply canonical sort algorithm.
    self.canonicalSort(code_points.items);
    // Encode as UTF-8 code units.
    var buf: [4]u8 = undefined;
    for (code_points.items) |dcp| {
        const len = try unicode.utf8Encode(dcp, &buf);
        try result.appendSlice(buf[0..len]);
    }
    // NFKD result.
    return result.toOwnedSlice();
}

/// toNFKD will decompose the code points in str, producing a slice of u8 with the new bytes.
/// This method produces a normalization of type NFKD as per Unicode. Given the recursive nature of 
/// this method, a std.heap.ArenaAllocator is the recommeded type of allocator to pass in. The 
/// caller can then easily free all memory with just a call to the arena's deinit method.
pub fn toNFKD(self: *Self, allocator: *mem.Allocator, str: []const u8) anyerror![]u8 {
    // No deinit here, to be freed by caller.
    var result = std.ArrayList(u8).init(allocator);
    // This we can deinit.
    var code_points = std.ArrayList(u21).init(self.allocator);
    defer code_points.deinit();
    // Gather decomposed code points.
    var iter = (try unicode.Utf8View.init(str)).iterator();
    while (iter.nextCodepoint()) |cp| {
        try code_points.appendSlice(try self.codePointKD(allocator, cp));
    }
    // Apply canonical sort algorithm.
    self.canonicalSort(code_points.items);
    // Encode as UTF-8 code units.
    var buf: [4]u8 = undefined;
    for (code_points.items) |dcp| {
        const len = try unicode.utf8Encode(dcp, &buf);
        try result.appendSlice(buf[0..len]);
    }
    // NFKD result.
    return result.toOwnedSlice();
}

fn cccLess(self: Self, lhs: u21, rhs: u21) bool {
    return self.ccc_map.combiningClass(lhs) < self.ccc_map.combiningClass(rhs);
}

fn canonicalSort(self: Self, cp_list: []u21) void {
    var i: usize = 0;
    while (true) {
        if (i >= cp_list.len) break;
        var start: usize = i;
        while (i < cp_list.len and self.ccc_map.combiningClass(cp_list[i]) != 0) : (i += 1) {}
        sort(u21, cp_list[start..i], self, cccLess);
        i += 1;
    }
}

fn decomposeHangul(self: Self, cp: u21) [3]u21 {
    const SBase: u21 = 0xAC00;
    const LBase: u21 = 0x1100;
    const VBase: u21 = 0x1161;
    const TBase: u21 = 0x11A7;
    const LCount: u21  = 19;
    const VCount: u21  = 21;
    const TCount: u21  = 28;
    const NCount: u21  = 588; // VCount * TCount
    const SCount: u21  = 11172; // LCount * NCount

    const SIndex: u21 = cp - SBase;
    const LIndex: u21 = SIndex / NCount;
    const VIndex: u21 = (SIndex % NCount) / TCount;
    const TIndex: u21 = SIndex % TCount;
    const LPart: u21 = LBase + LIndex;
    const VPart: u21 = VBase + VIndex;
    var TPart: u21 = 0;
    if (TIndex != 0) TPart = TBase + TIndex;

    return [3]u21{LPart, VPart, TPart};
}

fn isHangulPrecomposed(self: Self, cp: u21) bool {
    if (self.han_map.syllableType(cp)) |kind| {
        return switch (kind) {
            .LV, .LVT => true,
            else => false,
        };
    } else {
        return false;
    }
}

fn allDone(dcs: []const Decomposed) bool {
    for (dcs) |dc| {
        if (dc != .same) return false;
    }
    return true;
}
