
    return instance;
}}

const Self = @This();
pub fn deinit(self: *Self) void {{
    self.map.deinit();
}}

pub const Decomposed = union(enum) {{
    same: u21,
    seq: []const u21,
}};

/// decomposeCodePoint will convert a code point into its component code points if applicable.
/// Returns null if the code point cannot be decomposed.
pub fn decomposeCodePoint(self: Self, cp: u21) Decomposed {{
    if (self.map.get(cp)) |seq| {{
        return .{{ .seq = seq }};
    }} else {{
        return .{{ .same = cp }};
    }}
}}

/// decomposeString converts a string into a string where complex code points are decomposed into
/// their component code points. This method may return an error because of allocation. Caller must 
/// free returned memory.
pub fn decomposeString(self: *Self, str: []const u8) ![]const u8 {{
    var buf = std.ArrayList(u8).init(self.allocator);
    defer buf.deinit();
    var cp_iter = (try unicode.Utf8View.init(str)).iterator();
    while (cp_iter.nextCodepoint()) |cp| {{
        switch (self.decomposeCodePoint(cp)) {{
            .same => |dcp| {{
                const s = try self.toUtf8Bytes(dcp);
                defer self.allocator.free(s);
                try buf.appendSlice(s);
            }},
            .seq => |seq|  {{
                for (seq) |dcp| {{
                    const s = try self.toUtf8Bytes(dcp);
                    defer self.allocator.free(s);
                    try buf.appendSlice(s);
                }}
            }},
        }}
    }}
    return buf.toOwnedSlice();
}}

fn toUtf8Bytes(self: *Self, cp: u21) ![]const u8 {{
    var buf = std.ArrayList(u8).init(self.allocator);
    defer buf.deinit();
    var buf2: [4]u8 = undefined;
    var len = try unicode.utf8Encode(cp, &buf2);
    try buf.appendSlice(buf2[0..len]);
    return buf.toOwnedSlice();
}}
