
    return instance;
}

pub fn deinit(self: *Self) void {
    self.ccc_map.deinit();
    self.map.deinit();
}

/// mapping retrieves the decomposition mapping for a code point as per the UCD.
pub fn mapping(self: Self, cp: u21) Decomposed {
    return if (self.map.get(cp)) |dc| dc else .{ .same = cp };
}

/// decompose takes a code point and returns a sequence of code points that represent its full decomposition.
/// Note that the sequence could be just a single code point, and in that case it can even be the same
/// code point that was passed in. Given the recursive nature of this method, an std.heap.ArenaAllocator 
/// is the recommeded type of allocator to pass in. The caller can then easily free all memory with just
/// a call to the arena's deinit method.
pub fn decompose(self: Self, allocator: *mem.Allocator, cp: u21) anyerror![]u21 {
    const src = [1]Decomposed{ .{ .single = cp } };
    const dcs = try self.decompose_full(allocator, &src);
    var result = try allocator.alloc(u21, dcs.len);
    for (dcs) |dc, index| {
        result[index] = dc.same;
    }
    return result;
}

/// decompose_full recursively performs decomposition until full decomposition is obtained. Given the 
/// recursive nature of this method, a std.heap.ArenaAllocator is the recommeded type of allocator to
/// pass in. The caller can then easily free all memory with just a call to the arena's deinit method.
pub fn decompose_full(self: Self, allocator: *mem.Allocator, dcs: []const Decomposed) anyerror![]const Decomposed {
    // Base case;
    if (allDone(dcs)) return dcs;

    var rdcs = std.ArrayList(Decomposed).init(allocator);
    defer rdcs.deinit();
    for (dcs) |dc| {
        switch (dc) {
            .same => try rdcs.append(dc),
            .single => |cp| {
                const m = [1]Decomposed{ self.mapping(cp) };
                try rdcs.appendSlice(try self.decompose_full(allocator, &m));
            },
            .canon => |seq| {
                for (seq) |cp| {
                    const m = [1]Decomposed{ self.mapping(cp) };
                    try rdcs.appendSlice(try self.decompose_full(allocator, &m));
                }
            },
            .compat => |seq| {
                for (seq) |cp| {
                    const m = [1]Decomposed{ self.mapping(cp) };
                    try rdcs.appendSlice(try self.decompose_full(allocator, &m));
                }
            },
        }
    }
    return rdcs.toOwnedSlice();
}

/// normalize will decompose the code points in str, producing a slice of u8 with the new bytes.
/// This method produces a normalization of type NFKD as per Unicode. Given the recursive nature of 
/// this method, a std.heap.ArenaAllocator is the recommeded type of allocator to pass in. The 
/// caller can then easily free all memory with just a call to the arena's deinit method.
pub fn normalize(self: *Self, allocator: *mem.Allocator, str: []const u8) anyerror![]u8 {
    // No deinit here, to be freed by caller.
    var result = std.ArrayList(u8).init(allocator);
    // This we can deinit.
    var code_points = std.ArrayList(u21).init(self.allocator);
    defer code_points.deinit();
    // Gather decomposed code points.
    var iter = (try unicode.Utf8View.init(str)).iterator();
    while (iter.nextCodepoint()) |cp| {
        try code_points.appendSlice(try self.decompose(allocator, cp));
    }
    // Apply canonical sort algorithm.
    self.canonicalSort(code_points.items);
    // Encode as UTF-8 code units.
    var buf: [4]u8 = undefined;
    for (code_points.items) |dcp| {
        std.debug.print("{x}\n", .{dcp});
        const len = try unicode.utf8Encode(dcp, &buf);
        try result.appendSlice(buf[0..len]);
    }
    // NFKD result.
    return result.toOwnedSlice();
}

fn cccLess(self: Self, lhs: u21, rhs: u21) bool {
    return self.ccc_map.combiningClass(lhs) < self.ccc_map.combiningClass(rhs);
}

fn canonicalSort(self: Self, cp_list: []u21) void {
    var i: usize = 0;
    while (true) {
        if (i >= cp_list.len) break;
        var start: usize = i;
        while (i < cp_list.len and self.ccc_map.combiningClass(cp_list[i]) != 0) : (i += 1) {}
        sort(u21, cp_list[start..i], self, cccLess);
        i += 1;
    }
}

fn allDone(dcs: []const Decomposed) bool {
    for (dcs) |dc| {
        if (dc != .same) return false;
    }
    return true;
}

