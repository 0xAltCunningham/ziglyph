// Autogenerated from http://www.unicode.org/Public/UCD/latest/ucd/UCD.zip by running ucd_gen.sh.
//! Unicode decomposition map.

const std = @import("std");
const mem = std.mem;
const sort = std.sort.sort;
const unicode = std.unicode;

const Context = @import("../../../context.zig").Context;
const CccMap = @import("../DerivedCombiningClass/CccMap.zig");
const HangulMap = @import("../HangulSyllableType/HangulMap.zig");

/// Decomposed is the result of a code point full decomposition. It can be one of:
/// * .src: Sorce code point.
/// * .same : Default canonical decomposition to the code point itself.
/// * .single : Singleton canonical decomposition to a different single code point.
/// * .canon : Canonical decomposition, which always results in two code points.
/// * .compat : Compatibility decomposition, which can results in at most 18 code points.
pub const Decomposed = union(enum) {{
    src: u21,
    same: u21,
    single: u21,
    canon: [2]u21,
    compat: []const u21,
}};

pub const Form = enum {{
    D, // Canonical Decomposition
    KD, // Compatibility Decomposition
}};

ccc_map: *CccMap,
hangul_map: *HangulMap,
map: std.AutoHashMap(u21, Decomposed),
dctx: ?*Context(.decompose),

const Self = @This();

pub fn init(allocator: *mem.Allocator) !Self {{
    var dctx = try Context(.decompose).init(allocator);

    var instance = Self{{
        .ccc_map = dctx.ccc_map,
        .hangul_map = dctx.hangul_map,
        .map = std.AutoHashMap(u21, Decomposed).init(dctx.allocator),
        .dctx = dctx,
    }};

    try instance.addEntries();

    return instance;
}}

pub fn initWithContext(ctx: anytype) !Self {{
    var instance = Self{{
        .ccc_map = ctx.ccc_map,
        .hangul_map = ctx.hangul_map,
        .map = std.AutoHashMap(u21, Decomposed).init(ctx.allocator),
        .dctx = null,
    }};

    try instance.addEntries();

    return instance;
}}

fn addEntries(self: *Self) !void {{
