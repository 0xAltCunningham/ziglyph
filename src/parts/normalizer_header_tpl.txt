// Autogenerated from http://www.unicode.org/Public/UCD/latest/ucd/UCD.zip by running ucd_gen.sh.
//! Unicode decomposition map.

const std = @import("std");
const mem = std.mem;
const sort = std.sort.sort;
const unicode = std.unicode;

const CaseFoldMap = @import("../CaseFolding/CaseFoldMap.zig");
const CccMap = @import("../DerivedCombiningClass/CccMap.zig");
const HangulMap = @import("../HangulSyllableType/HangulMap.zig");
const NFDCheck = @import("../DerivedNormalizationProps/NFDCheck.zig");

allocator: *mem.Allocator,
ccc_map: CccMap,
fold_map: CaseFoldMap,
hangul_map: HangulMap,
nfd_check: NFDCheck,

const Self = @This();

/// Decomposed is the result of a code point full decomposition. It can be one of:
/// * .src: Sorce code point.
/// * .same : Default canonical decomposition to the code point itself.
/// * .single : Singleton canonical decomposition to a different single code point.
/// * .canon : Canonical decomposition, which always results in two code points.
/// * .compat : Compatibility decomposition, which can results in at most 18 code points.
pub const Decomposed = union(enum) {
    src: u21,
    same: u21,
    single: u21,
    canon: [2]u21,
    compat: []const u21,
};

pub fn new(allocator: *mem.Allocator) Self {
    return Self{
        .allocator = allocator,
        .ccc_map = CccMap{},
        .fold_map = CaseFoldMap{},
        .hangul_map = HangulMap{},
        .nfd_check = NFDCheck{},
    };
}

/// mapping retrieves the decomposition mapping for a code point as per the UCD.
pub fn mapping(self: Self, cp: u21) Decomposed {
